#!/usr/bin/env python3
"""Regenerate display lookup table and brightness list in blacktip_dpv.lisp.

The source of truth lives in CSV files under ``blacktip_dpv/assets``:

* ``display_lut.csv`` describes every display frame (one row per rotation).
* ``brightness_levels.csv`` enumerates the brightness command bytes.

This script renders those CSV files back into the exact Lisp layout that the
firmware expects.  Run it after modifying either CSV file, or invoke ``make``
which calls this script automatically.

The generated code is inserted between the marker comments
``; <<DISPLAY_TABLE_BEGIN>>``/``; <<DISPLAY_TABLE_END>>`` and
``; <<BRIGHTNESS_TABLE_BEGIN>>``/``; <<BRIGHTNESS_TABLE_END>>``.

Usage::

    python tools/update_display_tables.py           # rewrite in-place
    python tools/update_display_tables.py --check   # verify already up-to-date

The ``--check`` mode exits with status 0 when the file already matches the CSV
content, or 1 when an update is required.  This is useful for CI enforcement.
"""
from __future__ import annotations

import argparse
import csv
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List

REPO_ROOT = Path(__file__).resolve().parents[1]
LISP_FILE = REPO_ROOT / "blacktip_dpv.lisp"
ASSET_DIR = REPO_ROOT / "assets"
DISPLAY_CSV = ASSET_DIR / "display_lut.csv"
BRIGHTNESS_CSV = ASSET_DIR / "brightness_levels.csv"
DISPLAY_BEGIN = "; <<DISPLAY_TABLE_BEGIN>>"
DISPLAY_END = "; <<DISPLAY_TABLE_END>>"
BRIGHTNESS_BEGIN = "; <<BRIGHTNESS_TABLE_BEGIN>>"
BRIGHTNESS_END = "; <<BRIGHTNESS_TABLE_END>>"
INDENT = "            "
BRIGHTNESS_INDENT = "        "


@dataclass
class DisplayRow:
    index: int
    name: str
    rotation: int
    bytes: List[int]

    @classmethod
    def from_dict(cls, row: dict[str, str]) -> "DisplayRow":
        data = [int(row[f"b{i}"], 10) for i in range(16)]
        return cls(index=int(row["index"], 10),
                   name=row["name"].strip(),
                   rotation=int(row["rotation"], 10),
                   bytes=data)

    def render(self) -> str:
        tokens: List[str] = []
        for idx, value in enumerate(self.bytes):
            if idx % 2 == 0:
                tokens.append(str(value))
            else:
                tokens.append(f"0x{value:02X}")
        token_str = " ".join(tokens)
        return f"{INDENT}{token_str} ; {self.name} rotation {self.rotation}"


def read_display_rows(path: Path) -> List[DisplayRow]:
    rows: List[DisplayRow] = []
    with path.open(newline="") as f:
        reader = csv.DictReader(f)
        required_fields = {"index", "name", "rotation"} | {f"b{i}" for i in range(16)}
        missing = required_fields - set(reader.fieldnames or [])
        if missing:
            raise ValueError(f"{path} is missing columns: {sorted(missing)}")
        for row in reader:
            rows.append(DisplayRow.from_dict(row))
    rows.sort(key=lambda r: r.index)
    return rows


def render_display_block(rows: Iterable[DisplayRow]) -> str:
    lines = [f"{INDENT}{DISPLAY_BEGIN}",
             f"{INDENT}; Autogenerated by tools/update_display_tables.py",
             *[r.render() for r in rows],
             f"{INDENT}{DISPLAY_END}"]
    return "\n".join(lines) + "\n"


def read_brightness_rows(path: Path) -> List[tuple[int, int, str]]:
    records: List[tuple[int, int, str]] = []
    with path.open(newline="") as f:
        reader = csv.DictReader(f)
        required = {"level", "value", "label"}
        missing = required - set(reader.fieldnames or [])
        if missing:
            raise ValueError(f"{path} is missing columns: {sorted(missing)}")
        for row in reader:
            level = int(row["level"], 10)
            value = int(row["value"], 10)
            label = row["label"].strip()
            records.append((level, value, label))
    records.sort(key=lambda item: item[0])
    return records


def render_brightness_block(records: Iterable[tuple[int, int, str]]) -> str:
    lines = [f"{BRIGHTNESS_INDENT}{BRIGHTNESS_BEGIN}",
             f"{BRIGHTNESS_INDENT}    ; Autogenerated by tools/update_display_tables.py"]
    for _, value, label in records:
        token = f"0x{value:02X}" if value else "0"
        if label:
            lines.append(f"{BRIGHTNESS_INDENT}    {token}; {label}")
        else:
            lines.append(f"{BRIGHTNESS_INDENT}    {token}")
    lines.append(f"{BRIGHTNESS_INDENT}{BRIGHTNESS_END}")
    return "\n".join(lines) + "\n"


def replace_block(original: str, begin: str, end: str, replacement: str) -> str:
    begin_idx = original.find(begin)
    if begin_idx == -1:
        raise ValueError(f"Could not locate marker '{begin}' in Lisp file")
    start_of_line = original.rfind('\n', 0, begin_idx)
    if start_of_line == -1:
        start_of_line = 0
    else:
        start_of_line += 1

    end_idx = original.find(end, begin_idx)
    if end_idx == -1:
        raise ValueError(f"Could not locate marker '{end}' in Lisp file")
    end_line_end = original.find('\n', end_idx)
    if end_line_end == -1:
        end_line_end = len(original)
    else:
        end_line_end += 1

    return original[:start_of_line] + replacement + original[end_line_end:]


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--check", action="store_true",
                        help="Only verify that the file matches the CSV data")
    args = parser.parse_args()

    displays = read_display_rows(DISPLAY_CSV)
    brightness = read_brightness_rows(BRIGHTNESS_CSV)

    replacement_display = render_display_block(displays)
    replacement_brightness = render_brightness_block(brightness)

    current = LISP_FILE.read_text()
    updated = replace_block(current, DISPLAY_BEGIN, DISPLAY_END, replacement_display)
    updated = replace_block(updated, BRIGHTNESS_BEGIN, BRIGHTNESS_END, replacement_brightness)

    if args.check:
        if updated == current:
            return 0
        print("Display tables are out of date.")
        return 1

    if updated != current:
        LISP_FILE.write_text(updated)
        print(f"Updated {LISP_FILE.relative_to(REPO_ROOT.parent)}")
    else:
        print("Display tables already up to date.")
    return 0


if __name__ == "__main__":  # pragma: no cover - script entry point
    raise SystemExit(main())
