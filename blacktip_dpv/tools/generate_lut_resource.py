#!/usr/bin/env python3
"""Generate a standalone LispBM resource file with display lookup tables.

This script creates a `display_lut_data.lisp` file containing both the display
lookup table and brightness levels as Lisp data structures. The main firmware
can load this file at runtime, avoiding the need to embed large data arrays
directly in the source.

Usage::

    python tools/generate_lut_resource.py

The output file is written to `generated/display_lut_data.lisp`.
"""
from __future__ import annotations

import csv
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List

REPO_ROOT = Path(__file__).resolve().parents[1]
ASSET_DIR = REPO_ROOT / "assets"
DISPLAY_CSV = ASSET_DIR / "display_lut.csv"
BRIGHTNESS_CSV = ASSET_DIR / "brightness_levels.csv"
OUTPUT_DIR = REPO_ROOT / "generated"
OUTPUT_FILE = OUTPUT_DIR / "display_lut_data.lisp"


@dataclass
class DisplayRow:
    index: int
    name: str
    rotation: int
    bytes: List[int]

    @classmethod
    def from_dict(cls, row: dict[str, str]) -> "DisplayRow":
        data = [int(row[f"b{i}"], 10) for i in range(16)]
        return cls(index=int(row["index"], 10),
                   name=row["name"].strip(),
                   rotation=int(row["rotation"], 10),
                   bytes=data)

    def render(self) -> str:
        """Render as Lisp list with comments."""
        tokens: List[str] = []
        for idx, value in enumerate(self.bytes):
            if idx % 2 == 0:
                tokens.append(str(value))
            else:
                tokens.append(f"0x{value:02X}")
        token_str = " ".join(tokens)
        return f"            {token_str} ; {self.name} rotation {self.rotation}"


def read_display_rows(path: Path) -> List[DisplayRow]:
    rows: List[DisplayRow] = []
    with path.open(newline="") as f:
        reader = csv.DictReader(f)
        required_fields = {"index", "name", "rotation"} | {f"b{i}" for i in range(16)}
        missing = required_fields - set(reader.fieldnames or [])
        if missing:
            raise ValueError(f"{path} is missing columns: {sorted(missing)}")
        for row in reader:
            rows.append(DisplayRow.from_dict(row))
    rows.sort(key=lambda r: r.index)
    return rows


def read_brightness_rows(path: Path) -> List[tuple[int, int, str]]:
    records: List[tuple[int, int, str]] = []
    with path.open(newline="") as f:
        reader = csv.DictReader(f)
        required = {"level", "value", "label"}
        missing = required - set(reader.fieldnames or [])
        if missing:
            raise ValueError(f"{path} is missing columns: {sorted(missing)}")
        for row in reader:
            level = int(row["level"], 10)
            value = int(row["value"], 10)
            label = row["label"].strip()
            records.append((level, value, label))
    records.sort(key=lambda item: item[0])
    return records


def render_resource_file(displays: Iterable[DisplayRow],
                         brightness: Iterable[tuple[int, int, str]]) -> str:
    """Generate the complete LispBM resource file content."""
    lines = [
        "; Auto-generated display lookup table resource file",
        "; Generated by tools/generate_lut_resource.py",
        "; DO NOT EDIT - changes will be overwritten",
        "",
        "; Display lookup table - contains all screen patterns for each rotation",
        "(define display-lut-data [",
    ]
    for row in displays:
        lines.append(row.render())
    lines.append("])")
    lines.append("")
    lines.append("; Brightness command bytes indexed by brightness level")
    lines.append("(define brightness-lut-data [")
    for _, value, label in brightness:
        token = f"0x{value:02X}" if value else "0"
        lines.append(f"    {token}; {label}")
    lines.append("])")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    displays = read_display_rows(DISPLAY_CSV)
    brightness = read_brightness_rows(BRIGHTNESS_CSV)

    content = render_resource_file(displays, brightness)

    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    OUTPUT_FILE.write_text(content)
    
    print(f"Generated {OUTPUT_FILE.relative_to(REPO_ROOT.parent)}")
    print(f"  {len(displays)} display frames")
    print(f"  {len(brightness)} brightness levels")
    return 0


if __name__ == "__main__":  # pragma: no cover - script entry point
    raise SystemExit(main())
